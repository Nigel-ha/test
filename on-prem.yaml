parameters:
  - name: clusterName
    displayName: Cluster Name
    type: string
  - name: serviceConnection
    displayName: Service connection to use
    type: string

jobs:
  - job: cloud
    displayName: Generate EKS access token
    pool:
      name: prod-cloudpool-nix
    steps:
      - checkout: self
      - checkout: commonScripts
      - task: Bash@3
        displayName: "Install"
        inputs:
          targetType: "inline"
          script: |
            mv SCE-EKS/* .
            rm -rf SCE-EKS

            uname -a
            whoami
            # which kubectl

            mkdir -p keys
            mkdir -p scripts
            mkdir -p CF
            mv SCE-Common/keys/* keys/
            mv SCE-Common/scripts/*.* scripts/
            # mv SCE-Common/CF/product CF/
            rm -rf SCE-Common

            chmod u+x scripts/*.sh
            scripts/aws-cli.sh
            scripts/yqInstall.sh

      - task: AzureKeyVault@2
        displayName: 'Get ExternalID from KeyVault'
        inputs:
          azureSubscription: 'AKV Cloud Engineering Secret Reader'
          KeyVaultName: 'kv-bcz-cet'
          SecretsFilter: 'externalid'
          RunAsPreJob: false

      - task: AmazonWebServices.aws-vsts-tools.AWSShellScript.AWSShellScript@1
        displayName: 'Generate kubeconfig'
        env:
          externalID: $(externalid)
        inputs:
          awsCredentials: ${{ parameters.serviceConnection }}
          regionName: ap-southeast-2
          scriptType: inline
          inlineScript: |
            #!/bin/bash
            set -e
            . scripts/setup.sh "${{parameters.clusterName}}"

            # Generate kubeconfig file
            aws eks update-kubeconfig --name "${clusterName}" --region ap-southeast-2 --kubeconfig kubeconfig
            
            yq e '.clusters[].cluster."insecure-skip-tls-verify" = true' -i kubeconfig
            
            # Directly embed the token into the kubeconfig without using a variable
            python -c 'import sys, yaml, json; config=yaml.safe_load(sys.stdin); config["users"][0]["user"]={"token": "'$(aws eks get-token --cluster-name "${clusterName}" --region ap-southeast-2 --query 'status.token' --output text)'"}; yaml.safe_dump(config, sys.stdout, default_flow_style=False)' < kubeconfig > kubeconfig_modified

            # Replace the original kubeconfig file
            mv kubeconfig_modified kubeconfig

            # # Generate token
            # token=$(aws eks get-token --cluster-name "${clusterName}" --region ap-southeast-2 --query 'status.token' --output text)

            # # Convert kubeconfig from YAML to JSON
            # python -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout)' < kubeconfig > kubeconfig.json

            # # Use jq to replace the exec section with the token
            # jq --arg token "$token" '.users[0].user = { "token": $token }' kubeconfig.json > kubeconfig_modified.json

            # # Convert the modified JSON back to YAML
            # python -c 'import sys, yaml, json; yaml.safe_dump(json.load(sys.stdin), sys.stdout, default_flow_style=False)' < kubeconfig_modified.json > kubeconfig_modified

            # # Replace the original kubeconfig file
            # mv kubeconfig_modified kubeconfig

            # # Verify kubeconfig (do not display sensitive data)
            # #kubectl config view --flatten --minify

            # Copy kubeconfig to artifact staging directory
            mkdir -p $(Build.ArtifactStagingDirectory)
            cp kubeconfig $(Build.ArtifactStagingDirectory)/kubeconfig

      - task: PublishPipelineArtifact@1
        displayName: 'Publish kubeconfig Artifact'
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/kubeconfig'
          artifact: 'kubeconfig-artifact'
          allowUnsecure: true

      - task: AmazonWebServices.aws-vsts-tools.AWSShellScript.AWSShellScript@1
        displayName: 'Generate EKS Token and Retrieve Cluster Info'
        name: generate
        env:
          externalID: $(externalid)
        inputs:
          awsCredentials: ${{ parameters.serviceConnection }}
          regionName: ap-southeast-2
          scriptType: inline
          inlineScript: |
            . scripts/setup.sh "${{parameters.clusterName}}"
            # Fetch the EKS token
            token=$(aws eks get-token --cluster-name "${clusterName}" --query 'status.token' --output text)
            # Fetch the cluster CA certificate
            # cluster_ca=$(aws eks describe-cluster --name "${clusterName}" --query 'cluster.certificateAuthority.data' --output text)
            # echo "Length of cluster_ca: ${#cluster_ca}"

            # Fetch the NLB alias
            nlb_alias=$(aws cloudformation describe-stacks --stack-name "${stackName}" --query 'Stacks[0].Outputs[?OutputKey==`NLBAlias`].OutputValue' --output text)
            if [[ -z "$nlb_alias" ]]; then 
              echo "No NLBAlias export found for ${stackName}"
              exit 1
            fi
            # Fetch the EKS API endpoint domain (without the https:// prefix)
            eks_domain=$(aws eks describe-cluster --name "${clusterName}" --query 'cluster.endpoint' --output text | sed 's|https://||')
            
            # echo "##vso[task.setvariable variable=cluster_ca;isOutput=true;issecret=true]$cluster_ca"
            echo "##vso[task.setvariable variable=nlb_alias;isOutput=true]$nlb_alias"
            echo "##vso[task.setvariable variable=eks_domain;isOutput=true]$eks_domain"


  - job: onPrem
    displayName: Deploy
    dependsOn: cloud
    variables:
      # cluster_ca: $[ dependencies.cloud.outputs['generate.cluster_ca'] ]
      nlb_alias: $[ dependencies.cloud.outputs['generate.nlb_alias'] ]
      eks_domain: $[ dependencies.cloud.outputs['generate.eks_domain'] ]

    pool:
      name: Prod-ReleasePool-Lower
    steps:
    - task: PowerShell@2
      displayName: 'Install kubectl'
      inputs:
        targetType: 'inline'
        script: |
          # Variables
          $kubectlUrl = "https://nexus.bcz.gov.au/repository/raw-thirdparty/kubenetes/kubectl/v1.31.0/kubectl.exe"
          $destinationPath = "$(Build.ArtifactStagingDirectory)\kubectl.exe"  # Destination to save kubectl

          # Log the download information
          Write-Host "Downloading kubectl from Nexus: $kubectlUrl"
          
          # Download the file
          Invoke-WebRequest -Uri $kubectlUrl -OutFile $destinationPath

          # Check if the file exists
          if (Test-Path $destinationPath) {
            Write-Host "kubectl downloaded successfully to $destinationPath"
          } else {
            Write-Host "Failed to download kubectl."
            exit 1
          }

          # Add the directory to PATH
          $env:PATH += ";$(Build.ArtifactStagingDirectory)"

          # Verify kubectl version
          & kubectl.exe version --client

    - task: PowerShell@2
      displayName: 'Update Windows Hosts File with EKS Domain and NLB IP'
      env:
        nlb_alias: $(nlb_alias)
        eks_domain: $(eks_domain)
      inputs:
        targetType: 'inline'
        script: |
            # Set environment variables
            $env:nlb_alias = '$(nlb_alias)'
            $env:eks_domain = '$(eks_domain)'
            
            try {
                $NLB_IP = [System.Net.Dns]::GetHostAddresses($env:nlb_alias) | Select-Object -First 1 | ForEach-Object { $_.IPAddressToString }
            } catch {
                Write-Error "Failed to resolve NLB alias to IP address."
                exit 1
            }
            
            if (-not $NLB_IP) {
                Write-Error "Failed to get IP address for NLB alias."
                exit 1
            }
            
            Write-Host "NLB IP Address: $NLB_IP"
            Write-Host "EKS Domain: $($env:eks_domain)"
            
            # Update the Windows Hosts File
            $HostsFile = "C:\Windows\System32\drivers\etc\hosts"
            $HostsEntry = "$NLB_IP`t$($env:eks_domain)"
            
            # Check if entry already exists
            $HostsContent = Get-Content -Path $HostsFile -ErrorAction Stop
            if ($HostsContent -contains $HostsEntry) {
                Write-Host "Hosts file already contains the required entry."
            } else {
                # Add the entry to the hosts file
                Add-Content -Path $HostsFile -Value $HostsEntry -ErrorAction Stop
                Write-Host "Hosts file updated successfully."
            }

            cat $HostsFile
          # # Run the script with administrative privileges
          # # This option is available only for self-hosted agents
          # # For Microsoft-hosted agents, this step will fail due to lack of permissions
          # errorActionPreference: 'stop'
          # pwsh: true
          # continueOnError: false
          # # Ensure the agent runs with sufficient privileges
          # # You might need to configure the agent to run as an administrator
    - task: DownloadPipelineArtifact@2
      displayName: 'Download kubeconfig Artifact'
      inputs:
        buildType: 'current'
        artifactName: 'kubeconfig-artifact'  # Must match the artifact name in the cloud job
        targetPath: '$(Pipeline.Workspace)'  # Downloads to $(Pipeline.Workspace)

    # - task: PowerShell@2
    #   displayName: 'Test'
    #   env:
    #     eks_domain: $(eks_domain)
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #         # Define the EKS domain (replace with your actual EKS API endpoint)

    #         $env:eks_domain = '$(eks_domain)'

    #         # Define the kubeconfig source and target paths
    #         $kubeconfigSource = Join-Path -Path "$(Pipeline.Workspace)" -ChildPath "kubeconfig"
    #         $kubeconfigTarget = "$env:USERPROFILE\.kube\config"

    #         Write-Host "kubeconfigSource: $kubeconfigSource"
    #         Write-Host "kubeconfigTarget: $kubeconfigTarget"

    #         # Ensure the source file exists
    #         if (-Not (Test-Path $kubeconfigSource)) {
    #             Write-Error "kubeconfig file not found at $kubeconfigSource"
    #             exit 1
    #         }

    #         # Ensure the .kube directory exists
    #         New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\.kube" | Out-Null

    #         # Copy the kubeconfig file to the .kube directory
    #         Copy-Item -Path $kubeconfigSource -Destination $kubeconfigTarget -Force

    #         Write-Host "kubeconfig copied to $kubeconfigTarget"

    #         # Set NO_PROXY environment variable
    #         if ($env:NO_PROXY) {
    #           $env:NO_PROXY = $env:NO_PROXY + ",$env:eks_domain"
    #         } else {
    #           $env:NO_PROXY = $env:eks_domain
    #         }
    #         Write-Host "NO_PROXY is set to $env:NO_PROXY"

    #         # Resolve the EKS domain to the NLB IP address
    #         try {
    #             $NLB_IP = [System.Net.Dns]::GetHostAddresses($env:eks_domain) | Select-Object -First 1 | ForEach-Object { $_.IPAddressToString }
    #         } catch {
    #             Write-Error "Failed to resolve EKS domain to IP address."
    #             exit 1
    #         }

    #         if (-Not $NLB_IP) {
    #             Write-Error "Failed to get IP address for EKS domain."
    #             exit 1
    #         }

    #         Write-Host "EKS Domain: $env:eks_domain"
    #         Write-Host "NLB IP Address: $NLB_IP"

    #         # Update the Windows Hosts File
    #         $HostsFile = "C:\Windows\System32\drivers\etc\hosts"
    #         $HostsEntry = "$NLB_IP`t$env:eks_domain"

    #         # Check if entry already exists
    #         if ((Get-Content -Path $HostsFile -ErrorAction Stop) -contains $HostsEntry) {
    #             Write-Host "Hosts file already contains the required entry."
    #         } else {
    #             # Add the entry to the hosts file
    #             Add-Content -Path $HostsFile -Value $HostsEntry -ErrorAction Stop
    #             Write-Host "Hosts file updated successfully."
    #         }

    #         # Remove 'https://' if present
    #         $env:eks_domain = $env:eks_domain -replace '^https://', ''
    #         Write-Host "Connecting to EKS domain: $env:eks_domain"

    #         try {
    #             # Create a TCP client to connect to the EKS API endpoint on port 443
    #             Write-Host "Creating TCP client to $env:eks_domain on port 443"
    #             $tcpClient = New-Object System.Net.Sockets.TcpClient($env:eks_domain, 443)
    #             Write-Host "TCP client created successfully"
    #         } catch {
    #             Write-Error "Failed to connect to $env:eks_domain on port 443: $_"
    #             exit 1
    #         }

    #         # Create an SSL stream for the TCP connection
    #         try {
    #             $sslStream = New-Object System.Net.Security.SslStream($tcpClient.GetStream(), $false, { $true })
    #             Write-Host "SSL stream created successfully"
    #         } catch {
    #             Write-Error "Failed to create SSL stream: $_"
    #             $tcpClient.Close()
    #             exit 1
    #         }

    #         try {
    #             # Authenticate as a client without using any client certificates
    #             $sslProtocols = [System.Security.Authentication.SslProtocols]::Tls12
    #             Write-Host "Using SSL/TLS Protocols: $sslProtocols"
    #             $sslStream.AuthenticateAsClient($env:eks_domain, $null, $sslProtocols, $false)
    #             Write-Host "SSL authentication succeeded"

    #             # Get the remote certificate presented by the server
    #             $cert = $sslStream.RemoteCertificate
    #             $cert2 = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 $cert

    #             # Display certificate information
    #             Write-Host "Certificate Subject: $($cert2.Subject)"
    #             Write-Host "Certificate Issuer: $($cert2.Issuer)"
    #             Write-Host "Certificate Valid From: $($cert2.NotBefore)"
    #             Write-Host "Certificate Valid To: $($cert2.NotAfter)"
    #             Write-Host "Thumbprint: $($cert2.Thumbprint)"

    #             # Optionally, export the certificate to a file for further inspection
    #             $certPath = "$env:TEMP\eks_server_cert.cer"
    #             [System.IO.File]::WriteAllBytes($certPath, $cert2.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert))
    #             Write-Host "Certificate saved to: $certPath"
    #         } catch {
    #             Write-Error "SSL/TLS handshake failed: $($_.Exception.Message)"
    #             if ($_.Exception.InnerException) {
    #                 Write-Error "Inner Exception: $($_.Exception.InnerException.Message)"
    #             }
    #         } finally {
    #             # Close the SSL stream and TCP client
    #             $sslStream.Close()
    #             $tcpClient.Close()
    #         }

    - task: PowerShell@2
      displayName: 'Configure kubeconfig'
      env:
        eks_domain: $(eks_domain)
      inputs:
        targetType: 'inline'
        script: |
            $env:eks_domain = '$(eks_domain)'

            # Define the kubeconfig source and target paths
            $kubeconfigSource = Join-Path -Path "$(Pipeline.Workspace)" -ChildPath "kubeconfig"
            $kubeconfigTarget = "$env:USERPROFILE\.kube\config"

            Write-Host "kubeconfigSource: $kubeconfigSource"
            Write-Host "kubeconfigTarget: $kubeconfigTarget"

            # Ensure the source file exists
            if (-Not (Test-Path $kubeconfigSource)) {
                Write-Error "kubeconfig file not found at $kubeconfigSource"
                exit 1
            }

            # Ensure the .kube directory exists
            New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\.kube" | Out-Null

            # Copy the kubeconfig file to the .kube directory
            Copy-Item -Path $kubeconfigSource -Destination $kubeconfigTarget -Force

            Write-Host "kubeconfig copied to $kubeconfigTarget"

            # Check if the kubeconfig file contains "***"
            if (Test-Path $kubeconfigTarget) {
                # Search for the string "***" in the file
                $containsMaskedData = Select-String -Path $kubeconfigTarget -Pattern "\*\*\*" -Quiet

                if ($containsMaskedData) {
                    Write-Host "The kubeconfig file contains masked data (***)."
                } else {
                    Write-Host "The kubeconfig file does not contain masked data (***)."
                }
            } else {
                Write-Host "The kubeconfig file does not exist at: $kubeconfigTarget"
            }
            # Set NO_PROXY environment variable
            if ($env:NO_PROXY) {
              $env:NO_PROXY = $env:NO_PROXY + ",$env:eks_domain"
            } else {
              $env:NO_PROXY = $env:eks_domain
            }
            Write-Host "NO_PROXY is set to $env:NO_PROXY"

            # Resolve the EKS domain to the NLB IP address
            try {
                $NLB_IP = [System.Net.Dns]::GetHostAddresses($eks_domain) | Select-Object -First 1 | ForEach-Object { $_.IPAddressToString }
            } catch {
                Write-Error "Failed to resolve EKS domain to IP address."
                exit 1
            }

            if (-Not $NLB_IP) {
                Write-Error "Failed to get IP address for EKS domain."
                exit 1
            }

            Write-Host "EKS Domain: $eks_domain"
            Write-Host "NLB IP Address: $NLB_IP"

            # Update the Windows Hosts File
            $HostsFile = "C:\Windows\System32\drivers\etc\hosts"
            $HostsEntry = "$NLB_IP`t$eks_domain"

            # Check if entry already exists
            if ((Get-Content -Path $HostsFile -ErrorAction Stop) -contains $HostsEntry) {
                Write-Host "Hosts file already contains the required entry."
            } else {
                # Add the entry to the hosts file
                Add-Content -Path $HostsFile -Value $HostsEntry -ErrorAction Stop
                Write-Host "Hosts file updated successfully."
            }

            $env:PATH += ";$(Build.ArtifactStagingDirectory)"
            # Verify kubeconfig
            kubectl config view
            cat $kubeconfigTarget
            # Test kubectl connectivity
            kubectl get nodes --v=8

    # - task: PowerShell@2
    #   displayName: 'Configure kubeconfig'
    #   env:
    #     eks_token: $(eks_token)
    #     cluster_ca: $(cluster_ca)
    #     nlb_alias: $(nlb_alias)
    #     eks_domain: $(eks_domain)
    #   inputs:
    #     targetType: 'inline'
    #     script: |
    #       # Set environment variables
    #       $env:eks_token = '$(eks_token)'
    #       $env:cluster_ca = '$(cluster_ca)'
    #       $env:nlb_alias = '$(nlb_alias)'
    #       $env:eks_domain = '$(eks_domain)'
          
    #       Write-Host "Length of cluster_ca: $($env:cluster_ca.Length)"

    #       # Clean the cluster_ca to remove any whitespace or line breaks
    #       $cleanClusterCA = $env:cluster_ca -replace '\s+', ''

    #       # Output the length after cleaning
    #       Write-Host "Length of cleanClusterCA: $($cleanClusterCA.Length)"

    #       # Define the kubeconfig path
    #       $kubeconfigPath = "$env:USERPROFILE\.kube\config"
          
    #       # Ensure the .kube directory exists
    #       New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\.kube" | Out-Null
          
    #       # Create the kubeconfig content
    #       $kubeconfigContent = @"
    #       apiVersion: v1
    #       clusters:
    #       - cluster:
    #           server: https://$($env:eks_domain)
    #           certificate-authority-data: $($env:cluster_ca)
    #         name: eks-cluster
    #       contexts:
    #       - context:
    #           cluster: eks-cluster
    #           user: eks-user
    #         name: eks-context
    #       current-context: eks-context
    #       kind: Config
    #       preferences: {}
    #       users:
    #       - name: eks-user
    #         user:
    #           token: $($env:eks_token)
    #       "@

          
    #       # insecure-skip-tls-verify: true
    #       cat $kubeconfigPath
    #       # Write the kubeconfig content to the file
    #       $kubeconfigContent | Out-File -FilePath $kubeconfigPath -Encoding ascii
          
    #       if ($env:NO_PROXY) {
    #         $env:NO_PROXY = $env:NO_PROXY + ",$env:eks_domain"
    #       } else {
    #         $env:NO_PROXY = $env:eks_domain
    #       }
    #       $env:PATH += ";$(Build.ArtifactStagingDirectory)"
    #       Write-Host "kubeconfig created at $kubeconfigPath"
          
    #       # Verify kubeconfig
    #       kubectl config view
          
    #       # Test kubectl connectivity
    #       kubectl get nodes --v=8


